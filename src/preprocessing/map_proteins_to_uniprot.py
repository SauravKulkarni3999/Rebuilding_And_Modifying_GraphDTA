# -*- coding: utf-8 -*-
"""Untitled3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ARN1YySbQMJabB-TM1vsK94akbZdkzif
"""

# src/preprocessing/map_proteins_to_uniprot.py
import os
import argparse
from Bio import SeqIO
import pandas as pd
from tqdm import tqdm

def map_sequences_to_uniprot(query_fasta_path, uniprot_fasta_path, output_csv_path):
    """
    Maps sequences from a query FASTA to UniProt IDs by exact sequence matching.
    """
    try:
        query_records = list(SeqIO.parse(query_fasta_path, "fasta"))
        query_map = {str(record.seq): record.id for record in query_records}
        print(f"Loaded {len(query_records)} query sequences from {query_fasta_path}")
    except Exception as e:
        print(f"Error loading query FASTA {query_fasta_path}: {e}")
        return

    if not os.path.exists(uniprot_fasta_path):
        print(f"UniProt FASTA file not found at {uniprot_fasta_path}.")
        print("Please download it first (e.g., from https://ftp.uniprot.org/pub/databases/uniprot/current_release/knowledgebase/complete/uniprot_sprot.fasta.gz and unzip).")
        return

    print(f"Loading UniProt FASTA from {uniprot_fasta_path}. This may take a while...")
    try:
        uniprot_records = list(SeqIO.parse(uniprot_fasta_path, "fasta"))
        print(f"Loaded {len(uniprot_records)} UniProt sequences.")
    except Exception as e:
        print(f"Error loading UniProt FASTA {uniprot_fasta_path}: {e}")
        return

    matches = []
    print("Matching sequences...")
    for record in tqdm(uniprot_records, desc="Matching UniProt sequences"):
        seq = str(record.seq)
        if seq in query_map:
            query_id = query_map[seq]
            uniprot_accession = record.id.split("|")[1] if "|" in record.id else record.id
            matches.append({
                "Query_Protein_ID": query_id,
                "UniProt_ID": uniprot_accession,
                "Matched_Sequence": seq # Optional: for verification
            })
            # To avoid re-matching the same query sequence if it appears multiple times in UniProt (unlikely for exact match)
            # or if multiple query IDs have the same sequence (handled by query_map taking the first ID)
            # For efficiency with very large query sets, could remove matched seq from query_map
            # del query_map[seq]
            # if not query_map: break


    df_matches = pd.DataFrame(matches)

    # Handle cases where multiple UniProt IDs might match the same query sequence (if query_map[seq] was not unique, though it is by design)
    # or more importantly, if a query sequence didn't find a match.
    found_query_ids = set(df_matches["Query_Protein_ID"])
    for query_id in query_map.values():
        if query_id not in found_query_ids:
             matches.append({
                "Query_Protein_ID": query_id,
                "UniProt_ID": None,
                "Matched_Sequence": None
            })

    df_final_matches = pd.DataFrame(matches).drop_duplicates(subset=["Query_Protein_ID"]).reset_index(drop=True)


    os.makedirs(os.path.dirname(output_csv_path), exist_ok=True)
    df_final_matches.to_csv(output_csv_path, index=False)
    print(f"Saved {len(df_final_matches)} unique query protein mappings to: {output_csv_path}")
    print(f"Found UniProt IDs for {df_final_matches['UniProt_ID'].notna().sum()} query proteins.")

def main():
    parser = argparse.ArgumentParser(description="Map protein sequences from a FASTA file to UniProt IDs.")
    parser.add_argument("--query_fasta", type=str, required=True,
                        help="Path to the query FASTA file (e.g., davis_proteins.fasta).")
    parser.add_argument("--uniprot_fasta", type=str, required=True,
                        help="Path to the local UniProt/Swiss-Prot FASTA file (uniprot_sprot.fasta).")
    parser.add_argument("--output_csv", type=str, required=True,
                        help="Path to save the resulting CSV mapping file.")

    args = parser.parse_args()
    map_sequences_to_uniprot(args.query_fasta, args.uniprot_fasta, args.output_csv)

if __name__ == "__main__":
    # Example:
    # python src/preprocessing/map_proteins_to_uniprot.py --query_fasta ./data/davis/davis_proteins.fasta --uniprot_fasta ./data/external/uniprot_sprot.fasta --output_csv ./data/processed/davis/davis_uniprot_mapping.csv
    # Ensure uniprot_sprot.fasta is downloaded and placed in ./data/external/
    main()