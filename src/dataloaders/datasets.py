# -*- coding: utf-8 -*-
"""Untitled5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uj8L3FEePTQqlDV0KJUZCKkGYdVG8Ie2
"""

# src/dataloaders/datasets.py
import torch
from torch.utils.data import Dataset

class GraphDTADataset(Dataset):
    """
    Dataset class for GraphDTA (Drug Graphs + Protein Sequences).
    """
    def __init__(self, affinity_df, drug_graphs, protein_sequences,
                 drug_id_col="Drug_Index", protein_id_col="Protein_Index", affinity_col="Affinity"):
        self.data_pairs = []

        # Convert IDs in drug_graphs and protein_sequences to the type used in affinity_df if necessary
        # Assuming they are already compatible (e.g., all integers)

        for _, row in affinity_df.iterrows():
            d_idx = row[drug_id_col]
            p_idx = row[protein_id_col]
            y = row[affinity_col]

            if d_idx in drug_graphs and p_idx in protein_sequences:
                drug_graph = drug_graphs[d_idx]
                # protein_seq is already a tensor from preprocessing
                protein_seq_tensor = protein_sequences[p_idx]
                self.data_pairs.append((drug_graph, protein_seq_tensor, torch.tensor([y], dtype=torch.float)))
            # else:
            #     print(f"Warning: Skipping pair D:{d_idx}, P:{p_idx} due to missing data.")


    def __len__(self):
        return len(self.data_pairs)

    def __getitem__(self, idx):
        return self.data_pairs[idx]


class GraphDTA3DDataset(Dataset):
    """
    Dataset class for GraphDTA-3D (Drug Graphs + Protein Graphs).
    """
    def __init__(self, affinity_df, drug_graphs, protein_graphs,
                 drug_id_col="Drug_Index", protein_id_col="Protein_Index", affinity_col="Affinity"):
        self.data_pairs = []

        # Ensure protein_graphs keys are of the same type as protein_id_col in affinity_df
        # If protein_graphs keys are strings from filenames and protein_id_col are ints, conversion is needed
        # For this implementation, we assume protein_graphs is already keyed correctly by integer Protein_Index.

        for _, row in affinity_df.iterrows():
            d_idx = row[drug_id_col]
            p_idx = int(row[protein_id_col]) # Ensure p_idx is int if keys are int
            y = row[affinity_col]

            if d_idx in drug_graphs and p_idx in protein_graphs:
                drug_graph = drug_graphs[d_idx]
                protein_graph = protein_graphs[p_idx]
                self.data_pairs.append((drug_graph, protein_graph, torch.tensor([y], dtype=torch.float)))
            # else:
            #     if d_idx not in drug_graphs:
            #         print(f"Warning: Drug {d_idx} not in drug_graphs. Skipping pair D:{d_idx}, P:{p_idx}")
            #     if p_idx not in protein_graphs:
            #         print(f"Warning: Protein {p_idx} not in protein_graphs. Skipping pair D:{d_idx}, P:{p_idx}")


    def __len__(self):
        return len(self.data_pairs)

    def __getitem__(self, idx):
        return self.data_pairs[idx]