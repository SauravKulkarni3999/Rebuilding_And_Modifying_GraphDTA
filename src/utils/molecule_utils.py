# -*- coding: utf-8 -*-
"""molecule_utils.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tPqb6OG6_lAEZXy9HqofcHBH2p83FI_a
"""

# src/utils/molecule_utils.py
import torch
from rdkit import Chem
from torch_geometric.data import Data

# Atom feature encoder
ATOM_TYPES = ['C', 'N', 'O', 'F', 'P', 'S', 'Cl', 'Br', 'I', 'H', 'Si', 'Mg',
              'Na', 'Ca', 'Fe', 'As', 'Al', 'B', 'V', 'K', 'Tl', 'Sb', 'Sn',
              'Ag', 'Co', 'Se', 'Ti', 'Zn', 'Li', 'Cu', 'Au', 'Ni', 'Cd', 'Mn', 'Cr', 'Unknown']

DEGREE_SET = [0, 1, 2, 3, 4, 5, 6, 7]
TOTAL_NUM_HS_SET = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
TOTAL_VALENCE_SET = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
IS_AROMATIC_SET = [0, 1] # False, True
CHIRAL_TAG_SET = [0, 1, 2, 3, 4, 5, 6, 7, 8] # RDKit ChiralType enum values can be mapped if needed,
                                          # but GraphDTA often uses a simplified set.
                                          # For now, using a generic range based on common practice.

def one_hot_encoding(x, allowable_set):
    """
    Creates a one-hot encoding for a feature x based on an allowable set.
    Adds an 'Unknown' category if x is not in the allowable set.
    """
    encoding = [int(x == s) for s in allowable_set]
    if sum(encoding) == 0: # If x is not in allowable_set
        encoding.append(1) # Mark as 'Unknown'
    else:
        encoding.append(0) # Not 'Unknown'
    return encoding

def atom_to_feature_vector(atom):
    """
    Converts an RDKit atom object to a feature vector.
    The feature vector has a consistent length of 83.
    """
    symbol_feature = one_hot_encoding(atom.GetSymbol(), ATOM_TYPES[:-1]) # Exclude 'Unknown' for direct mapping
    degree_feature = one_hot_encoding(atom.GetDegree(), DEGREE_SET)
    total_num_hs_feature = one_hot_encoding(atom.GetTotalNumHs(), TOTAL_NUM_HS_SET)
    total_valence_feature = one_hot_encoding(atom.GetTotalValence(), TOTAL_VALENCE_SET)
    is_aromatic_feature = one_hot_encoding(atom.GetIsAromatic(), IS_AROMATIC_SET)
    chiral_tag_feature = one_hot_encoding(int(atom.GetChiralTag()), CHIRAL_TAG_SET) # Cast ChiralType to int

    # Concatenate all features
    # Lengths: 36 (atom_types) + 9 (degree) + 12 (total_num_hs) + 12 (total_valence) + 3 (is_aromatic) + 10 (chiral_tag) = 82
    # The model expects 83. The original notebook `KIBA_Drug_Graph_Generation.ipynb` implicitly creates 83.
    # atom_types: 36 (actual types) + 1 (for unknown) = 37
    # degree: 8 + 1 = 9
    # total_num_hs: 11 + 1 = 12
    # total_valence: 11 + 1 = 12
    # is_aromatic: 2 + 1 = 3
    # chiral_tag: 9 + 1 = 10
    # Total: 37 + 9 + 12 + 12 + 3 + 10 = 83.
    # This means the one_hot_encoding should use the full ATOM_TYPES list including 'Unknown'.

    return (one_hot_encoding(atom.GetSymbol(), ATOM_TYPES) +
            one_hot_encoding(atom.GetDegree(), DEGREE_SET) +
            one_hot_encoding(atom.GetTotalNumHs(), TOTAL_NUM_HS_SET) +
            one_hot_encoding(atom.GetTotalValence(), TOTAL_VALENCE_SET) +
            one_hot_encoding(atom.GetIsAromatic(), IS_AROMATIC_SET) +
            one_hot_encoding(int(atom.GetChiralTag()), CHIRAL_TAG_SET))


def smiles_to_graph(smiles):
    """
    Converts a SMILES string to a PyTorch Geometric Data object.
    Uses the atom_to_feature_vector function for node features.
    """
    mol = Chem.MolFromSmiles(smiles)
    if mol is None:
        return None

    node_feats = []
    for atom in mol.GetAtoms():
        node_feats.append(atom_to_feature_vector(atom))

    edge_index_list = []
    for bond in mol.GetBonds():
        i = bond.GetBeginAtomIdx()
        j = bond.GetEndAtomIdx()
        edge_index_list.append([i, j])
        edge_index_list.append([j, i]) # Undirected graph

    x = torch.tensor(node_feats, dtype=torch.float)
    if not edge_index_list: # Handle molecules with no bonds (e.g., single atoms if they were to occur)
        edge_index = torch.empty((2, 0), dtype=torch.long)
    else:
        edge_index = torch.tensor(edge_index_list, dtype=torch.long).t().contiguous()

    return Data(x=x, edge_index=edge_index)

if __name__ == '__main__':
    # Example usage:
    aspirin_smiles = "CC(=O)OC1=CC=CC=C1C(=O)O"
    graph = smiles_to_graph(aspirin_smiles)
    if graph:
        print(f"Generated graph for Aspirin: {graph}")
        print(f"Node feature shape: {graph.x.shape}") # Should be [num_atoms, 83]
        print(f"Edge index shape: {graph.edge_index.shape}")

    # Test an atom feature vector
    mol_aspirin = Chem.MolFromSmiles(aspirin_smiles)
    if mol_aspirin:
        first_atom = mol_aspirin.GetAtoms()[0]
        features = atom_to_feature_vector(first_atom)
        print(f"Features for the first atom of Aspirin ({first_atom.GetSymbol()}): {features}")
        print(f"Length of feature vector: {len(features)}")