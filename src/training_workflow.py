# -*- coding: utf-8 -*-
"""Untitled8.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qP2mfcskqLmQU5Z4Ic9_qasBzhdNbhaX
"""

# src/training_workflow.py
import torch
import torch.nn as nn
from tqdm import tqdm

# Assuming metrics are imported from utils
from utils.metrics import rmse_torch, concordance_index_torch

def train_epoch(model, device, loader, optimizer, criterion, model_type="GraphDTA"):
    """
    Runs a single training epoch.
    model_type can be "GraphDTA" or "GraphDTA3D" to handle different input types.
    """
    model.train()
    total_loss = 0

    for batch_idx, data_batch in enumerate(tqdm(loader, desc="Training", leave=False)):
        if model_type == "GraphDTA":
            drug_data, protein_data, affinity = data_batch
            drug_data = drug_data.to(device)
            protein_data = protein_data.to(device) # This is protein sequence tensor
        elif model_type == "GraphDTA3D":
            drug_data, protein_data, affinity = data_batch
            drug_data = drug_data.to(device)
            protein_data = protein_data.to(device) # This is protein graph batch
        else:
            raise ValueError("Invalid model_type specified for training.")

        affinity = affinity.to(device)

        optimizer.zero_grad()
        output = model(drug_data, protein_data)
        loss = criterion(output, affinity)
        loss.backward()
        optimizer.step()
        total_loss += loss.item()

    return total_loss / len(loader)

def evaluate_epoch(model, device, loader, criterion, model_type="GraphDTA"):
    """
    Evaluates the model on a given dataset loader.
    model_type can be "GraphDTA" or "GraphDTA3D".
    """
    model.eval()
    all_preds, all_true = [], []
    total_val_loss = 0
    num_samples = 0

    with torch.no_grad():
        for data_batch in tqdm(loader, desc="Evaluating", leave=False):
            if model_type == "GraphDTA":
                drug_data, protein_data, affinity = data_batch
                drug_data = drug_data.to(device)
                protein_data = protein_data.to(device) # Protein sequence tensor
            elif model_type == "GraphDTA3D":
                drug_data, protein_data, affinity = data_batch
                drug_data = drug_data.to(device)
                protein_data = protein_data.to(device) # Protein graph batch
            else:
                raise ValueError("Invalid model_type specified for evaluation.")

            affinity = affinity.to(device)
            output = model(drug_data, protein_data)

            loss = criterion(output, affinity)
            total_val_loss += loss.item() * affinity.size(0) # Weighted by batch size
            num_samples += affinity.size(0)

            all_preds.extend(output.cpu().tolist())
            all_true.extend(affinity.cpu().tolist())

    avg_val_loss = total_val_loss / num_samples if num_samples > 0 else 0

    # Ensure tensors for metric calculation
    preds_tensor = torch.tensor(all_preds, dtype=torch.float)
    true_tensor = torch.tensor(all_true, dtype=torch.float)

    rmse = rmse_torch(preds_tensor, true_tensor)
    ci = concordance_index_torch(true_tensor, preds_tensor) # CI expects lists or 1D tensors

    metrics = {
        'loss': avg_val_loss,
        'rmse': rmse,
        'ci': ci
    }
    return metrics